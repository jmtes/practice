<--- DON'T DO THIS EVER --->
- Just don't use eval() or with. They modify the already compiled/optimized scope at runtime, resulting in performance hits. Use strict mode so you don't even THINK about using them.

<--- LEXICAL SCOPE --->
- A language whose scope is determined at compiled time has a scope model that is lexical.
- The key concept is that the lexical scope of a program is controlled entirely by the placement of functions, blocks, and scopes in relation to each other.
- If a variable is block-scoped with let or const, then it's associated with the nearest enclosing {...} block rather than its enclosing function (as with var).
- Scopes are planned out during compilation, but they aren't actually allocated in memory until runtime.

<--- SCOPE BUBBLES METAPHOR --->
- Each scope bubble is entirely contained within its parent scope bubble. A scope is never partially in two different outer scopes.
- Think of marbles being sorted into buckets by color.
- Each marble (variable/identifier) is colored based on which bucket (bubble) it's DECLARED in, not the color of the scope it may be ACCESSED from.
- When the JS engine finds a variable declaration as it's parsing a program during compilation, it asks which scope it's currently in and then sorts that variable into that scope bubble.
- A scope can reference any variable in any outside scope, but not for any inside scopes.
- The colored buckets and the marbles they contain are determined during compilation and the info is used for marble color lookups during runtime.

<--- CONVERSATION WITH FRIENDS METAPHOR --->
- Basically, the compiler asks the scope manager if an identifier exists in the current scope and if not, the scope manager creates it. If so, the declaration is ignored.
- When the compiler runs into function declarations, loops, block scopes, etc. it requests a new scope bucket AND scope manager. There can be multiple scope managers.
- Once the engine starts executing the code, it will ask the current scope's manager to look up a target reference if it runs into one and assign to it once it's found.
- If the engine runs into a source reference, it will ask the scope manager if it knows anything by that identifier and if not, the scope manager will tell the engine to try the next outer scope.
- When the engine runs into a source reference for a function, it will ask the scope manager to instantiate the function's scope so that it can execute its code.

<--- HOISTING --->
- All function and variable declarations are hoisted to the top of the block, with functions going to the very top.
- All variables made with the function declaration are automatically initialized to their associated function references.
- All declarations made with var will be initialized to undefined.
- Declarations made with let will not be initialized (in TDZ) and the associated variables cannot be used until its declaration-and-init are executed.

<--- NESTED SCOPE --->
- Each scope gets its own scope manager instance each time that scope is executed. 
- Each scope automatically has all its identifiers registered because of hoisting.
- Any time an identifier reference cannot be found in the current scope, the next outer scope is consulted, and so on until there are no more scopes to consult.

<--- LOOKUP FAILURES --->
- If a target reference cannot be found and strict-mode is not enabled, the global scope's scope manager will just create an accidental global variable to fulfill that target assignment.
- This, and many other things, can be prevented with strict mode.

<--- "LOOKUP" IS MOSTLY CONCEPTUAL --->
- The color of a marble, the meta info of which scope a variable originates from, is USUALLY known during the initial compilation processing and will not change during runtime.
- Thus, the engine doesn't actually have to look up which scope a source reference comes from during execution because it already knows!
- Avoiding the need for runtime lookups is a key optimization benefit for lexical scope.

<--- WHEN A MARBLE COLOR ISN'T KNOWN DURING COMPILATION --->
- Consider a reference to a variable that isn't declared in any scopes in the CURRENT file.
  - Remember that each JS file is a separate program as far the JS compiler is concerned!
  - If no declaration is found, that's not necessarily an error. 
  - Another file in the runtime may have declared that variable in the shared global scope.
  - If that's the case, the determination of whether the variable was declared in an available scope may need to be deferred to the runtime.
- Essentially, any reference to a variable in a program that is initially undeclared is left as an uncolored marble during compilation.
  - That color cannot be determined until other relevant files have been compiled and application runtime begins.
  - So indeed in this case some sort of runtime "lookup" is performed, but only once at most becuase the marble's color is immutable.

<--- SHADOWING --->
- When you choose to shadow a variable from an outer scope, from that downward it's now impossible for any marble to be colored as the shadowed variable.
- It's still possible to access a global identifier that has been shadowed, but not through a typical lexical identifier reference.
  - For a standalone JS file in a browser environment, once could access a shadowed variable by getting it as an attribute of the window object ( window.<SHADOWED VARIABLE NAME> )
  - This trick only works for global scope variables that were declared with var or function though.
  - But it's whatever because doing this isn't very good practice.
  - Generally, don't shadow global variables that you need to access and don't access global variables that you've shadowed.
- Variables that exist in any scope other than the global scope are completely inaccessible from an inner scope where they've been shadowed.

<--- ILLEGAL SHADOWING --->
- let can shadow var, but var can't shadow let.
  - This is because var puts a variable in the scope of the enclosing FUNCTION rather than just the enclosing BLOCK. Variable declarations made with var are hoisted to the top of the FUNCTION rather than the top of the BLOCK it's in.

<--- ARROW FUNCTION NAME SCOPE --->
- Other than being anonymous and having no declarative form, arrow functions have the same rules with respect to lexical scope as functions declared with the function keyword do.
- An arrow function still creates a separate, inner nested scope bucket.
- Variable declarations inside that bucket have the same behavior as those in functions declared with the function keyword.

<--- THE GLOBAL SCOPE --->
- When multiple scripts are loaded in a browser, variable declarations that weren't made in a function scope are processed in the global scope.
  - Because the global scope is the only shared resource between two separate files, this enables them to work together as modules.
- JS exposes its built-ins in the global scope:
  - primtives: undefined, null, Infinity, NaN
  - natives: Date(), Object(), String(), etc.
  - global functions: eval(), parseInt(), etc.
  - namespaces: Math, Atomics, JSON
  - friends of JS: Intl, WebAssembly
- The environment that is hosting JS exposes its built-ins in the global scope as well:
  - console and its methods
  - the DOM (window, document, etc.)
  - timers (setTimeout(), etc.)
  - web platform APIs: fetch, navigator, history, geolocation, WebRTC, etc.
- Node exposes several elements "globally", but they're technically not in the global scope.
  - require()
  - __dirname
  - module
  - URL
- The global scope should NOT be a dumping ground for every variable in your application. However, the global scope is an important glue for virtually every JS app.

<--- SYNONYMOUS GLOBAL VARIABLES AND GLOBAL OBJECT PROPERTIES --->
- A global object property can be shadowed by a global variable.
- It's a bad idea to do so though. Do not create a divergence between the global object and the global scope.