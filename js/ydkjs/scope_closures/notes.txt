<--- DON'T DO THIS EVER --->
- Just don't use eval() or with. They modify the already compiled/optimized scope at runtime, resulting in performance hits. Use strict mode so you don't even THINK about using them.

<--- LEXICAL SCOPE --->
- A language whose scope is determined at compiled time has a scope model that is lexical.
- The key concept is that the lexical scope of a program is controlled entirely by the placement of functions, blocks, and scopes in relation to each other.
- If a variable is block-scoped with let or const, then it's associated with the nearest enclosing {...} block rather than its enclosing function (as with var).
- Scopes are planned out during compilation, but they aren't actually allocated in memory until runtime.

<--- SCOPE BUBBLES METAPHOR --->
- Each scope bubble is entirely contained within its parent scope bubble. A scope is never partially in two different outer scopes.
- Think of marbles being sorted into buckets by color.
- Each marble (variable/identifier) is colored based on which bucket (bubble) it's DECLARED in, not the color of the scope it may be ACCESSED from.
- When the JS engine finds a variable declaration as it's parsing a program during compilation, it asks which scope it's currently in and then sorts that variable into that scope bubble.
- A scope can reference any variable in any outside scope, but not for any inside scopes.
- The colored buckets and the marbles they contain are determined during compilation and the info is used for marble color lookups during runtime.

<--- CONVERSATION WITH FRIENDS METAPHOR --->
- Basically, the compiler asks the scope manager if an identifier exists in the current scope and if not, the scope manager creates it. If so, the declaration is ignored.
- When the compiler runs into function declarations, loops, block scopes, etc. it requests a new scope bucket AND scope manager. There can be multiple scope managers.
- Once the engine starts executing the code, it will ask the current scope's manager to look up a target reference if it runs into one and assign to it once it's found.
- If the engine runs into a source reference, it will ask the scope manager if it knows anything by that identifier and if not, the scope manager will tell the engine to try the next outer scope.
- When the engine runs into a source reference for a function, it will ask the scope manager to instantiate the function's scope so that it can execute its code.

<--- HOISTING --->
- The term for registering a variable at the top of its enclosing scope, even though its declaration may appear further down it.
- All identifiers are registered to their respective scopes during compile time.
- Each identifier is created at the beginning of the scope it belongs to EVERY TIME that scope is entered.
- All function and variable declarations are hoisted to the top of the block.
  - The functions are hoisted first, so they go to the very tippy top.
- All variables made with the function declaration are automatically initialized to their associated function references.
- All declarations made with var will be initialized to undefined.
- Declarations made with let will not be initialized (in TDZ) and the associated variables cannot be used until its declaration-and-init are executed.
- Hoisting itself is a metaphor.
  - It often calls to mind images of the JS engine simply reordering code but this isn't accurate.
  - The JS engine has to fully parse the code in order to accurately find variable/function declarations and scope boundaries.
    - This all happens in the first phase of the two-phase compilation process.
- If we want to be accurate, "hoisting" should only refer to the compile-time operation of generating runtime instructions for the automatic registration of a variable at the beginning of its scope each time that scope is entered.

<--- NESTED SCOPE --->
- Each scope gets its own scope manager instance each time that scope is executed. 
- Each scope automatically has all its identifiers registered because of hoisting.
- Any time an identifier reference cannot be found in the current scope, the next outer scope is consulted, and so on until there are no more scopes to consult.

<--- LOOKUP FAILURES --->
- If a target reference cannot be found and strict-mode is not enabled, the global scope's scope manager will just create an accidental global variable to fulfill that target assignment.
- This, and many other things, can be prevented with strict mode.

<--- "LOOKUP" IS MOSTLY CONCEPTUAL --->
- The color of a marble, the meta info of which scope a variable originates from, is USUALLY known during the initial compilation processing and will not change during runtime.
- Thus, the engine doesn't actually have to look up which scope a source reference comes from during execution because it already knows!
- Avoiding the need for runtime lookups is a key optimization benefit for lexical scope.

<--- WHEN A MARBLE COLOR ISN'T KNOWN DURING COMPILATION --->
- Consider a reference to a variable that isn't declared in any scopes in the CURRENT file.
  - Remember that each JS file is a separate program as far the JS compiler is concerned!
  - If no declaration is found, that's not necessarily an error. 
  - Another file in the runtime may have declared that variable in the shared global scope.
  - If that's the case, the determination of whether the variable was declared in an available scope may need to be deferred to the runtime.
- Essentially, any reference to a variable in a program that is initially undeclared is left as an uncolored marble during compilation.
  - That color cannot be determined until other relevant files have been compiled and application runtime begins.
  - So indeed in this case some sort of runtime "lookup" is performed, but only once at most becuase the marble's color is immutable.

<--- SHADOWING --->
- When you choose to shadow a variable from an outer scope, from that downward it's now impossible for any marble to be colored as the shadowed variable.
- It's still possible to access a global identifier that has been shadowed, but not through a typical lexical identifier reference.
  - For a standalone JS file in a browser environment, once could access a shadowed variable by getting it as an attribute of the window object ( window.<SHADOWED VARIABLE NAME> )
  - This trick only works for global scope variables that were declared with var or function though.
  - But it's whatever because doing this isn't very good practice.
  - Generally, don't shadow global variables that you need to access and don't access global variables that you've shadowed.
- Variables that exist in any scope other than the global scope are completely inaccessible from an inner scope where they've been shadowed.

<--- ILLEGAL SHADOWING --->
- let can shadow var, but var can't shadow let.
  - This is because var puts a variable in the scope of the enclosing FUNCTION rather than just the enclosing BLOCK. Variable declarations made with var are hoisted to the top of the FUNCTION rather than the top of the BLOCK it's in.

<--- ARROW FUNCTION NAME SCOPE --->
- Other than being anonymous and having no declarative form, arrow functions have the same rules with respect to lexical scope as functions declared with the function keyword do.
- An arrow function still creates a separate, inner nested scope bucket.
- Variable declarations inside that bucket have the same behavior as those in functions declared with the function keyword.

<--- THE GLOBAL SCOPE --->
- When multiple scripts are loaded in a browser, variable declarations that weren't made in a function scope are processed in the global scope.
  - Because the global scope is the only shared resource between two separate files, this enables them to work together as modules.
- JS exposes its built-ins in the global scope:
  - primtives: undefined, null, Infinity, NaN
  - natives: Date(), Object(), String(), etc.
  - global functions: eval(), parseInt(), etc.
  - namespaces: Math, Atomics, JSON
  - friends of JS: Intl, WebAssembly
- The environment that is hosting JS exposes its built-ins in the global scope as well:
  - console and its methods
  - the DOM (window, document, etc.)
  - timers (setTimeout(), etc.)
  - web platform APIs: fetch, navigator, history, geolocation, WebRTC, etc.
- Node exposes several elements "globally", but they're technically not in the global scope.
  - require()
  - __dirname
  - module
  - URL
- The global scope should NOT be a dumping ground for every variable in your application. However, the global scope is an important glue for virtually every JS app.

<--- SYNONYMOUS GLOBAL VARIABLES AND GLOBAL OBJECT PROPERTIES --->
- A global object property can be shadowed by a global variable.
- It's a bad idea to do so though. Do not create a divergence between the global object and the global scope.

<--- THE BROWSER JS ENVIRONMENT --->
- Can be considered the most pure environment JS can be run in with respect to treatment of global scope.
  - This doesn't necessarily mean nothing is ever automatically added.
  - Rather, it means that there's minimal intrusion on the code or interference with its behavior.
- There are some corner cases such as with window.name though.

<--- WEB WORKERS --->
- A web platform extension which allows a JS file to run in a separate thread (OS-wise) from the one that's running the main browser-hosted JS.
  - Because of this, they're restricted in their communications with the main app thread to avoid/control race conditions and stuff.
  - Thus, they do not have access to the DOM.
  - Some web APIs are still available to them though, such as navigator.
- A web worker is treated as a wholly separate program, so it does not share the global scope with the main JS program.
  - The browser's JS engine is still running the code though, so the same global scope behavior purity can be expected of it.
- Because a web worker lacks access to the DOM, the window alias for the global scope doesn't exist, so `self` is used instead (eg self.name).

<--- DEVELOPER TOOLS CONSOLE/REPL --->
- While dev tools are convenient and useful, they are NOT suitable environments to determine or verify some of the explicit and nuanced behaviors of an actual JS program context.

<--- ES6 MODULES AND THE GLOBAL SCOPE --->
- ES6 modules encourage a minimization of reliance on the global scope by allowing for the importation of whichever modules you need for the current module's operation. 
- Thus, you less often see usage of the global scope or its global object.
- Despite this, there are still plenty of JS and web globals that you will continue to access from the global scope, whether you realize it or not!

<--- NODE --->
- To reiterate, Node defines a number of "globals" like require(), but they're not actually identifiers in the global scope.
  - They're simply provided in the available scope to every module.
  - You can think of them as a bit like parameters provided to every Module function as illustrated in the file ./node.js
- Refer to ./node.js for notes on how Node wraps modules kind of like functions.
- Unlike a browser environment, Node treats every JS file it loads, including the main one you start the Node process with, as a module.
  - Thus, the module wrapping always occurs!
  - This means your main Node program does NOT act like a JS file loaded in a browser would with respect to scope!

<--- DEFINING GLOBAL VARIABLES IN NODE --->
- Because Node treats every single JS file as a module, declaring a variable at the top level of a Node file doesn't automatically make it global.
- To actually make globals in Node, you have to add properties to Node's automatically provided `global`.
  - It is ostensibly a reference to the real global scope object.
  - See ./node-globals.js for an example.
  - Remember that `global` is defined by Node, not JS. It will not work in any other environment.

<--- VARIABLE RE-DECLARATION --->
- The only way to re-declare a variable is to use VAR for all (two or more) of its declarations.
- Re-declaration has always been allowed with VAR, but ES6 decided to disallow it with LET.
  - Hence, a SyntaxError is thrown if ever you re-declare a variable and at least one of the declarations was made with LET.
  - This is because re-declaration is seen as sloppy and bad practice by the TC39 body.
  - Also they felt that since re-declaration must be disallowed for CONST variables, the same should go for LET variables as well.

<--- REASSIGNING CONST DECLARATIONS --->
- Not allowed, will throw a TypeError
  - It is not a SyntaxError because syntax errors represent faults in the program that are caught during compile time and stop it from even executing.
  - On the other hand, TypeErrors represent faults that arise DURING program execution.

<--- SCOPING WITH LOOPS --->
- See ./scoping_with_loops.js

<--- UNINITIALIZED --->
- See ./uninitialized.js
- With VAR declarations, the variable is hoisted to the top of its scope and automaticallly initialized to "undefined".
- LET and CONST are not quite the same in this respect though.
  - They DO hoist, but they are not automatically initialized.
  - Auto-initialization of their variables is deferred until the moment in the code's sequencing where the original declaration appeared.
- A variable declared with LET or CONST is in the temporal dead zone, a state of uninitialization, until the program reaches its original declaration statement with the assignment attached.
  - This is the ONLY way it can be initialized.
  - An assignment by itself, separate from and coming before a declaration, is insufficient.
- Do not lump 'auto-registration of a variable at the top of its scope' together with 'auto-initialization' under the single term "hoisting". It should only refer to the former.
  - See ./let_const_hoisting.js

<--- TEMPORAL DEAD ZONE --->
- The time window wherein a variable (declared with LET or CONST) exists but is still uninitialized (not even to "undefined"!) and therefore cannot be accessed in any way
- Only the execution of the instructions left by the compiler at the point of the original declaration can peform that initialization, after which the TDZ is over and the variable is free to be used for the rest of the scope.
- To avoid TDZ errors, just always put your LET and CONST declarations at the top of their enclosing scopes.

<--- PRINCIPLE OF LEAST PRIVILEGE (POLP) --->
- A defensive posture to software architecture with a focus on system-level component design.
- Components of a system should be designed to function with least privilege, least access, least exposure.
- If each piece is connected with minimum-necessary capabilities, the overall system is stronger from a security standpoint.
  - A compromise or failure of one piece has a minimized impact on the rest of the system.

<--- PRINCIPLE OF LEAST EXPOSURE --->
- Aims to minimize the exposure of the variables/functions registered in each scope
- Essentially, default to exposing the bare minimum necessary and keep everything else as private as possible
- Variables should be declared in the lowest scopes possible in order to effectively "hide" them in scope.
- Just don't place everything in the global or even outer function scope

<--- WHY YOU SHOULDN'T JUST PLACE ALL YOUR VARIABLES IN THE GLOBAL SCOPE --->
- Naming collisions
  - Occurs if you use a common and useful variable/function name in two different parts of the program but the identifier comes from one shared scope
  - Bugs will likely occur as one part uses the variable/function in a way the other part doesn't expecte
  - Ex: All your loops using a single global i variable
- Unexpected behavior
  - Exposing variables/functions whose usage is otherwise private to a piece of a program allows other developers to use them in ways you didn't intend
  - Exposure of private details also invites those mith mal-intent to try to work around limitations you have imposed and do things with your software that shouldn't be allowed
  - Ex: If part of your program assumes an array contains all numbers, but someone else's code accesses and modifies the array to include booleans and strings, your code may then behave unexpectedly.
- Unintended dependency
  - Exposing variables/functions unnecessarily invites other developers to use and depend on those otherwise private pieces.
  - Creates a refactoring hazard in the future because now you cannot as easily refactor that variable/function without potentially breaking other parts of the code.

<--- HIDING IN FUNCTION SCOPE --->
- LET and CONST are block-scoped declarators, which means that their access is limited to the enclosing code block (denoted by curly braces) and whatever nested scopes it may contain.
- VAR and FUNCTION declarations are not block-scoped, but they can still be hidden by wrapping a FUNCTION scope around them.
  - See ./function_scoping.js

<--- IMMEDIATELY INVOKED FUNCTION EXPRESSIONS --->
- Useful for when we want to create a scope to hide variables/functions
- Can be used in any place in a JS program where an expression is allowed
- Can be named but are much more commonly kept anonymous
- Can be standalone or part of another statement
    - Ex: It can be the value assigned to a variable. This means its return will be assigned to that variable.
    - See ./standalone_iife.js
- Parentheses are required around standalone IIFEs to distinguish them as function expressions rather than declarations.
    - They're not required for IIFEs that are part of statements though.
    - Regardless, it's good to always wrap your IIFEs with parentheses for consistency and readability.

<--- IFFEs AND FUNCTION BOUNDARIES --->
- Because an IIFE is a full function, the function boundary alters the behavior of certain statements/constructs.
    - Thus, using one to define a scope can have some unintended consequences depending on the code around it.
- A RETURN statement in some piece of code would change its meaning if then wrapped in an IIFE
    - The RETURN would then refer to the IIFE's function
- Non arrow function IIFEs change the binding of a THIS keyword
- Statements like BREAK and CONTINUE won't operate across an IIFE boundary to control an outer loop or block
- Thus, if the code you need to wrap a scope around has a RETURN, THIS, BREAK, or CONTINUE in it, don't go for an IIFE.
    - Create the scope with a block instead of a function!

<--- SCOPING WITH BLOCKS --->
- Unnecessary identifier exposure can also be prevented using LET/CONST declarations with nested blocks.
- In general, any { .. } curly brace pair which is a statement will act as a block, but NOT NECESSARILY AS A SCOPE.
    - A block only becomes a scope if it needs to, to contain block scoped declarations made with LET/CONST present within it
- See ./scoping_with_blocks.js
- Blocks can be defined as part of a statement (like an IF or FOR).
- They can also be defined as bare standalone block statements, as is shown in the script above.
    - An explicit block of this sort without any declarations would not actually be a scope and thus serve no operational purpose.
    - It can be useful as a stylistic signal though.

<--- BLOCK SCOPING AND TDZ --->
- We've established that the risk of TDZ errors can be minimized by always putting LET/CONST declarations at the top of their enclosing scopes.
- If you find yourself putting a LET declaration in the middle of a scope block, think about whether or not that variable is actually needed for the entire block.
    - If not, then you should use an inner explicit block scope to narrow its exposure and stick to POLE!
    - Even if your program is small and it doesn't seem like over-exposing a variable would be that big a deal, it's good to make a habit of it!

<--- WHEN CURLY BRACES DO NOT DENOTE BLOCKS/SCOPES --->
- When around object literals
- When around class definitions
- When around function bodies
    - Although this may seem like a block, it technically isn't.
    - It's simply a single statement for the function body
    - It IS a function scope, though!
- When around the CASE clauses of a SWITCH statement

<--- VAR --->
- Refer to ./scoping_with_blocks.js
- Variables declared with VAR are attached to the nearest enclosing function scope, even if it appears inside a block.
- Only variables that belong to a whole function should be declared with VAR (the `buckets` variable in this example).
    - Thus, it should be used for any variable that is needed across all or most of a function so that such usage is obvious.
- Clearly signals to other developers "this variable is function-scoped".
    - Using LET in the top-level scope, especially if not in the first few lines or a function or when all the other declarations in blocks use LET, does not visually draw attention to the difference.

<--- VAR VS LET --->
- VAR better communicates "function-scoped" than LET does
- LET both communicates and achieves block-scoping where VAR is insufficient.
- As long as your program needs both function- and block-scoped variables, the best approach is to use BOTH VAR and LET together, each for their own best purpose.
- The best way to decide which one you want to use is to ask "What is the most minimal scope exposure that's sufficient for this variable?"
    - Once you answer that, you'll know whether a variable belongs in a block scope (LET) or the function scope (VAR).

<--- LIMITING THE EXPOSURE OF PARAMETERS? --->
- See ./scoping_with_blocks.js
- Although the parameter `names` isn't used across the whole function, there's no way to limit the scope of a parameter.
    - Hence why it behaves as a function-wide declaration regardless.

<--- BLOCK SCOPING WITH THE CATCH CLAUSE --->
- A CATCH block is not a scope unless a LET declaration is made inside of it.
- Variables declared with LET will be block-scoped to that CATCH clause.
- Variables declared with VAR will still be scoped to the nearest enclosing function.
- The ERR variable declared by a CATCH clause is block scoped to it.
- ES2019 changed CATCH clauses so that their declaration is optional.
    - So if you need to catch that an error occurred but you don't care which, you can omit the ERR declaration.
- See ./catch_block.js

<--- FUNCTION DECLARATIONS IN BLOCKS (FiB) --->
- See ./function_declarations_in_blocks.js
- One of the most common use-cases for placing a function declaration in a block is to conditionally define a function one way or another depending on some environment state.
    - Doing this is discouraged though, since allowing a program to define multiple versions of a function always makes it harder to reason about and maintain.