CHAPTER 2: VALUES

<--- ARRAYS --->
- Using DELETE On an array value will remove that slot from the array, but it does not update the length property, so be careful!
  - While logging the array at the empty slot will output "undefined", it will not behave the same as if it had been explicitly set to undefined.
  - See Example A in ../examples/arrays.js
- Arrays are numerically indexed, but because they are also objects, they can have STRING keys/properties added to them.
  - These do not count toward the length of the array.
  - Generally, just don't add string properties to arrays.
  - If you find yourself wanting to do so, you're probably better off using a plain object.
  - See Example B in ../examples/arrays.js

<--- ARRAY-LIKES --->
- Sometimes you will need to convert an array-like value (a numerically indexed collection of values) into a true array.
  - This is so you can use utilities like indexOf(...), forEach(...), etc.
- Various DOM query operations return lists of DOM elements that are not true arrays but are array-like enough for conversion.
- Functions can also expose the array-like arguments object to access the arguments as a list.
  - arguments has been deprecated as of ES6 though.
- Ways to convert an array-like value to a true array:
  1. With the slice(...) utility.
    - See Example A in ../examples/array_likes.js
  2. With ES6's Array.from(...) utility.
    - See Example B in ../examples.array_likes.js

<--- STRINGS --->
- It's a common belief that strings are essentially just arrays of characters, but that's not the case in JS!
  - See Example A in ../examples/strings.js
- Strings are immutable while arrays are mutable.
  - Many array methods that change an array's contents modify it in-place.
  - None of the string methods that alter a string's contents can modify it in-place.
  - Rather, they create and return new strings.
- Array methods that perform no mutations can be "borrowed" to deal with strings.
  - See Example B in ../examples/strings.js
- If you find yourself trying to use strings as arrays of characters, you're better off actually storing them as arrays of characters rather than as strings.
  - You will save yourself the hassle of converting between string and array!
  - You can always call join(...) on the array of characters whenever you actually need the string representation.

<--- NUMBERS --->
- JS has just one numeric type, NUMBER.
  - It includes both "integer" values and fractional decimal numbers.
- In JS, there are no true integers like there are in other languages.
  - An integer in JS is just a value that has no fractional decimal value.
  - The value 42.0 is as much an "integer" as 42.

<--- NUMBER SYNTAX --->
- Very large or very small numbers will by default be outputted in exponent form.
  - It looks the same as the output of the toExponential() method.
  - See Example A in ../examples/numbers.js
- You can specify how many decimal places a value is represented with using the toFixed(...) method.
  - See Example B in ../examples/numbers.js
- The toPrecision(...) method behaves similarly, but instead the amount of significant digits is specified.
  - See Example C in ../examples/numbers.js
- Number methods can be accessed directly on number literals.
  - You'd have to be careful with the dot notation though.
  - See Example D in ../examples/numbers.js
  - Overall, it's pretty uncommon to access methods directly on any of the primitive values.
- Numbers can be expressed in bases other than 10.
  - This includes binary, octal, and hexadecimal.
  - See Example E in ../examples/numbers.js

<--- DECIMAL VALUES --->
- Basically, floating point numbers cannot be trusted to be exact.
- A tiny "rounding error" value must be used as the tolerance for comparison.
  - This value is often called "machine epsilon".
  - ES6 predefines it as Number.EPSILON with the value 2^-52 .
- See Example F in ../examples/numbers.js
- The maximum floating point value that can be represented is roughly 1.798e+308 and is predefined as Number.MAX_VALUE .
- On the other hand, the minimum floating point value is roughly 5e-324 and is predefined as Number.MIN_VALUE .

<--- SAFE INTEGER RANGES --->
- Because of how numbers are represented, there's a range of "safe" values for the whole number "integers".
- The largest integer that can be safely represented is 2^53 - 1, which is 9007199254740991.
  - It's predefined in ES6 as Number.MAX_SAFE_INTEGER .
- The smallest integer that can be safely represented is -9007199254740991.
  - It's predefined in ES6 as Number.MIN_SAFE_INTEGER .
- The main way JS programs are confronted with such large numbers is when dealing with 64-bit IDs from databases.
  - These numbers cannot be represented accurately with the number type.
  - They must be stored in JS using their string representations.
  - Usually the strings only need to be compared and it's fine though.

<--- TESTING FOR INTEGERS --->
- You can use the ES6-specified Number.isInteger(...) method.
- See Example G in ../examples/numbers.js

<--- 32 BIT (SIGNED) INTEGERS --->
- Some numeric operations (like the bitwise operators) are only defined for 32-but numbers.
- The safe range for numbers used in that way has to be much smaller.
- Specifically, it is -2^31 to 2^31 - 1.
  - This would be -2147483648 to 2147483647.
- You may have to force a number value to a 32-bit signed integer value.
  - See Example H in ../examples/numbers.js

<--- SPECIAL VALUES --->

<--- NON-VALUE VALUES -->

