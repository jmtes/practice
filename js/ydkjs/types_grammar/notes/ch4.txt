CHAPTER 4: COERCION

<--- INTRO --->
- Coercion is quite the controversial topic!
- There have been many a debate over whether coercion is a useful feature or a design flaw of the language.
- The overwhelmingly prevalent opinion is that coercion is magical, evil, confusing, and just bad.
- Coercion has its pros and cons and it's up to you to decide whether or not it's appropriate for your program.

<--- CONVERTING VALUES --->
- There are two different terms for converting a value from one type to another:
  - If done explicitly, it's called "type casting".
  - If done implicitly (forced by the rules of how a value is used), it's called "coercion".
- In JS, most people refer to both as "coercion", so it may be more apt to distinguish the two with the terms "implicit coercion" and "explicit coercion".
  - Explicit coercion is when it's obvious from looking at the code that a type conversion is intentionally occurring.
  - Implicit coercion is when the type conversion occurs as a less obvious side effect of some other intentional operation.
  - See Example A in ../examples/coercion.js.
- The terms "explicit" and "implicit" are relative.
  - Remember that it's rare that you're the only one who'll ever read your code.
  - Even if you're an expert on JS and all its quirks, you must write your code with consideration for others that may have to work on it and that have less experience.
  - What is explicit for one developer may be implicit for another developer!
- JS coercions always result in one of the scalar primitives.
- No coercion can result in a complex value like an object or function.
  - The concept of boxing from Chapter 3 may seem to contradict this, but it's not really coercion in an accurate sense.

<--- ABSTRACT VALUE OPERATIONS --->
- An abstract operation in JS is basically an internal-only operation.

<--- TOSTRING --->
- When any non-string value is coerced to a string, the conversion is handled by the ToString abstract operation.
  - Technically it goes through the ToPrimitive abstract operation, but that will be covered in more detail later.
- Built-in primitive values have natural stringification.
- For regular objects, unless you specify your own, the default toString() will return the internal [[Class]].
  - Ex. "[object Object]"
- If an object has its own toString() method and you use the object in a string-like way, its toString() will be called automatically and the string result of that call will be used instead.
- Arrays have an overridden default toString() that stringifies as the string concatenation of all its values (each stringified themselves) with a comma between each one.
- See Example B in ../examples/coercion.js

<--- JSON STRINGIFICATION --->
- Serializing a value to a JSON-compatible string value is not the same thing as coercion!
- For most simple values, JSON stringification behaves exactly the same as toString() conversions, except the serialization result is ALWAYS a string.
  - These values include strings, numbers, booleans, and null.

<--- JSON-SAFE VALUES --->
- Any JSON-safe value can be stringified with JSON.stringify().
- The following values are NOT JSON-safe:
  - undefined
  - Functions
  - Symbols
  - Objects with circular references
- JSON.stringify() will automatically omit undefined, function, and symbol values when it comes across them.
  - If such a value is found in an array, that value is replaced by NULL so as to preserve the original array indices.
  - If such a value is found in an object, that property will simply be excluded.
  - See Example A in ../examples/json.js

<--- TOJSON() --->
- If an object value has a toJSON() method defined, this method will be called first to get a value to use for serialization.
  - This is helpful if you intend to JSON stringify an object that may contain non JSON-safe values!
  - See Example B in ../examples/json.js
- It's a common misconception that a toJSON() method should return the JSON stringification representation.
  - Unless you want to stringify the string itself though, which you likely won't, this is incorrect!
  - You should just return an object of whatever type of object you're trying to stringify and let JSON.stringify itself handle the stringification.
  - toJSON() should be interpreted as "to a JSON-safe value suitable for stringification" rather than "to a JSON string".

<--- JSON REPLACER --->
- An optional second argument can be passed to JSON.stringify() that is called the replacer.
- It's used to customize the recursive serialization of an object by providing a filtering mechanism for which properties should and should not be included.
  - It works similarly to how toJSON() can prepare a value for serialization.
- Replacer can be either an array or a function.
- If replacer is an array, it should be an array of strings.
  - Each string should specify a property name that is allowed to be included in the serialization of an object.
  - If a property exists that isn't in this list, it will be skipped.
- If replacer is a function, it will be called once for the object itself and then once for each property in the object.
  - Each time is passed two arguments: key and value.
  - To skip a key in the serialization, return undefined.
  - Otherwise, return the value provided.
- See Example C in ../examples/json.js

<--- JSON SPACE --->
- A third optional argument called space can also be passed to JSON.stringify(). 
- It's used as indentation for prettier human-friendly output.
- It can be a positive integer to indicate how many space characters can be used at each indentation level,
- OR it can be a string, in which case up to the first 10 characters will be used for each indentation level.


