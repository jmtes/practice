CHAPTER 4: COERCION

<--- INTRO --->
- Coercion is quite the controversial topic!
- There have been many a debate over whether coercion is a useful feature or a design flaw of the language.
- The overwhelmingly prevalent opinion is that coercion is magical, evil, confusing, and just bad.
- Coercion has its pros and cons and it's up to you to decide whether or not it's appropriate for your program.

<--- CONVERTING VALUES --->
- There are two different terms for converting a value from one type to another:
  - If done explicitly, it's called "type casting".
  - If done implicitly (forced by the rules of how a value is used), it's called "coercion".
- In JS, most people refer to both as "coercion", so it may be more apt to distinguish the two with the terms "implicit coercion" and "explicit coercion".
  - Explicit coercion is when it's obvious from looking at the code that a type conversion is intentionally occurring.
  - Implicit coercion is when the type conversion occurs as a less obvious side effect of some other intentional operation.
  - See Example A in ../examples/coercion.js.
- The terms "explicit" and "implicit" are relative.
  - Remember that it's rare that you're the only one who'll ever read your code.
  - Even if you're an expert on JS and all its quirks, you must write your code with consideration for others that may have to work on it and that have less experience.
  - What is explicit for one developer may be implicit for another developer!
- JS coercions always result in one of the scalar primitives.
- No coercion can result in a complex value like an object or function.
  - The concept of boxing from Chapter 3 may seem to contradict this, but it's not really coercion in an accurate sense.

<--- ABSTRACT VALUE OPERATIONS --->
- An abstract operation in JS is basically an internal-only operation.

<--- TOSTRING --->
- When any non-string value is coerced to a string, the conversion is handled by the ToString abstract operation.
  - Technically it goes through the ToPrimitive abstract operation, but that will be covered in more detail later.
- Built-in primitive values have natural stringification.
- For regular objects, unless you specify your own, the default toString() will return the internal [[Class]].
  - Ex. "[object Object]"
- If an object has its own toString() method and you use the object in a string-like way, its toString() will be called automatically and the string result of that call will be used instead.
- Arrays have an overridden default toString() that stringifies as the string concatenation of all its values (each stringified themselves) with a comma between each one.
- See Example B in ../examples/coercion.js

<--- JSON STRINGIFICATION --->
- Serializing a value to a JSON-compatible string value is not the same thing as coercion!
- For most simple values, JSON stringification behaves exactly the same as toString() conversions, except the serialization result is ALWAYS a string.
  - These values include strings, numbers, booleans, and null.

<--- JSON-SAFE VALUES --->
- Any JSON-safe value can be stringified with JSON.stringify().
- The following values are NOT JSON-safe:
  - undefined
  - Functions
  - Symbols
  - Objects with circular references
- JSON.stringify() will automatically omit undefined, function, and symbol values when it comes across them.
  - If such a value is found in an array, that value is replaced by NULL so as to preserve the original array indices.
  - If such a value is found in an object, that property will simply be excluded.
  - See Example A in ../examples/json.js

<--- TOJSON() --->
- If an object value has a toJSON() method defined, this method will be called first to get a value to use for serialization.
  - This is helpful if you intend to JSON stringify an object that may contain non JSON-safe values!
  - See Example B in ../examples/json.js
- It's a common misconception that a toJSON() method should return the JSON stringification representation.
  - Unless you want to stringify the string itself though, which you likely won't, this is incorrect!
  - You should just return an object of whatever type of object you're trying to stringify and let JSON.stringify itself handle the stringification.
  - toJSON() should be interpreted as "to a JSON-safe value suitable for stringification" rather than "to a JSON string".

<--- JSON REPLACER --->
- An optional second argument can be passed to JSON.stringify() that is called the replacer.
- It's used to customize the recursive serialization of an object by providing a filtering mechanism for which properties should and should not be included.
  - It works similarly to how toJSON() can prepare a value for serialization.
- Replacer can be either an array or a function.
- If replacer is an array, it should be an array of strings.
  - Each string should specify a property name that is allowed to be included in the serialization of an object.
  - If a property exists that isn't in this list, it will be skipped.
- If replacer is a function, it will be called once for the object itself and then once for each property in the object.
  - Each time is passed two arguments: key and value.
  - To skip a key in the serialization, return undefined.
  - Otherwise, return the value provided.
- See Example C in ../examples/json.js

<--- JSON SPACE --->
- A third optional argument called space can also be passed to JSON.stringify(). 
- It's used as indentation for prettier human-friendly output.
- It can be a positive integer to indicate how many space characters can be used at each indentation level,
- OR it can be a string, in which case up to the first 10 characters will be used for each indentation level.

<--- TONUMBER --->
- If any non-number value is used in a way that requires it to be a number, such as in a mathematical operation, the conversion is handled by the ToNumber abstract operation.
- Examples:
  - true become 1
  - false becomes 0
  - undefined becomes NaN
  - null becomes 0
- ToNumber for a string value essentially works for the most part like the rules/syntax for numeric literals.
  - If it fails, the result is NaN instead of a syntax error as with number literals.
  - Another thing to be aware of is that 0-prefixed octal numbers, while valid as number literals, are not handled as octals in this operation but rather as just normal base-10 decimals.
  - Refer back to Chapters 2 and 3 for a refresher!
- Before going through the ToNumber abstract operation, objects and arrays will first be converted to their primitive value equivalents.
  - They are then coerced into numbers according to the ToNumber rules just mentioned.
  - Refer to the TOPRIMITIVE section below.

<--- TOPRIMITIVE --->
- Object and arrays will first be converted to their primitive value before being coerced into something like a number.
- The ToPrimitve abstract operation will consult the array/object in question to see if it has a valueOf() method.
- If valueOf() is available and returns a primitive value, THAT value is used for the coercion.
- If valueOf() is NOT available but toString() is, then the latter will provide the value for coercion.
- If neither can provide a primitive value, then a TypeError is thrown.
- See Example C in ../examples/coercion.js

<--- TOBOOLEAN --->
- JS has actual keywords TRUE and FALSE, and they behave exactly as you'd expect of boolean values.
- It's a common misconception that the values 1 and 0 are identical to true/false.
  - This is true in other languages, but not JS!
- In JS, the numbers are numbers and the booleans are booleans.
  - You can coerce 1 to true (and vice versa) or 0 to false (and vice versa), but they're not the same.

<--- TRUTHY AND FALSY VALUES --->
- All of JS's values can be divided into two categories:
  1. Values that become false if coerced into a boolean
  2. Values that become true if coerced into a boolean

<--- FALSY VALUES --->
- JS defines a specific, narrow list of values that will result in false if coerced into a boolean value:
  - undefined
  - null
  - false
  - +0, -0, and NaN
  - ''

<--- TRUTHY VALUES --->
- JS doesn't really define a list of truthy values like it does for falsy ones.
- Basically, anything not explicitly on the falsy list is truthy.
- Really, the only thing the spec says explicitly on the matter is that all objects are truthy.
  - Is that really the case though?
  - See section FALSY OBJECTS below!

<--- FALSY OBJECTS --->
- You might be tempted to think a falsy object implies an object wrapper around a falsy value such as '', 0, or false.
  - See Example A in ../examples/falsy_objects.js
- In actuality, falsy objects can show up in your JS program, but are not actually a part of JS themselves.
- There are cases where browsers have created they own sort of exotic values behavior, namely this idea of "falsy objects", on top of regular JS semantics.
- A "falsy object" is a value that looks and acts like a normal object (with properties, etc.), but when it's coerced into a boolean, it becomes false.

<--- DOCUMENT.ALL --->
- This is the most well-known case of a falsy object.
